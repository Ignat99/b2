#define _CRT_NONSTDC_NO_DEPRECATE
#include <shared/system.h>
#include <shared/testing.h>
#include <shared/log.h>
#include <6502/6502.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
extern "C" {
#include "perfect6502.h"
}
#include <stdlib.h>
#include <limits.h>
#include <string>
#include <vector>

LOG_DEFINE(DEBUG,"",&log_printer_stdout_and_debugger)

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
// Compare 6502 simulator bus behaviour against perfect6502.
//
// The original plan was just to use visual6502 URLs: design tests in
// the Visual6502 simulator page, then copy and paste URL into code.
// So there's a bunch of code to run stuff based on the data in a
// Visual6502 URL. But this proved rather unwieldy; I found it a bit
// hard to keep on top of all those long URLs, especially when there
// are several related tests that differ only in a couple of settings.
//
// So the tests are generated by the code in AddTestCases, then turned
// into a URL, and then the URL is used to run the tests :-/ - though
// it's not totally useless, because that way it can also output an
// HTML page with some clickable links.
//
// Limitations:
//
// - only a subset of query parameters are supported: a, d, r, irq0,
//   irq1, nmi0, nmi1, steps (others are ignored)
//
// - IRQ/NMI signals must go low or high on odd half-cycles only (even
//   cycles are the phi2->ph1 transition, which the 6502 simulator
//   does atomically)
//
// - the CPU internal state isn't tracked, as the simulator doesn't
//   copy the 6502's internal state perfectly on each cycle. Only the
//   address bus, data bus and rw line are checked
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// Initial contents of the visual6502 sim memory, starting at 0x0000.
static const uint8_t DEFAULT_MEMORY[]={
    0xa9,0x00,0x20,0x10,0x00,0x4c,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
    0xe8,0x88,0xe6,0x0f,0x38,0x69,0x02,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

struct PinState {
    int cycle;
    int level;

    PinState(int level,int cycle);
};

PinState::PinState(int level_,int cycle_):
    cycle(cycle_),
    level(level_)
{
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

static uint8_t g_mem[65536];
static std::vector<PinState> g_irqs,g_nmis;
static int g_num_test_cycles;

/* static void ClearMem(void) { */
/*     memset(g_mem,0,65536); */
/* } */

static uint8_t unhex(char c) {
    if(c>='0'&&c<='9') {
        return (uint8_t)(c-'0');
    } else if(c>='a'&&c<='f') {
        return (uint8_t)(c-'a'+10);
    } else if(c>='A'&&c<='F') {
        return (uint8_t)(c-'A'+10);
    } else {
        TEST_TRUE(0);
        return 0;
    }
}

/* static void LoadMem(uint16_t addr,const char *str) { */
/*     const char *c=str; */
/*     while(*c!=0) { */
/*         TEST_TRUE(isspace(*c)||isxdigit(*c)); */
/*         if(isspace(*c)) { */
/*             // ignore. */
/*             ++c; */
/*         } else if(isxdigit(*c)) { */
/*             TEST_TRUE(isxdigit(c[1])); */
/*             g_mem[addr++]=(unhex(*c)<<4)|unhex(c[1]); */
/*             c+=2; */
/*         } */
/*     } */
/* } */

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

std::string strprintfv(const char *fmt,va_list v) {
    char *str;
    if(vasprintf(&str,fmt,v)==-1) {
        perror("vasprintf failed");
        exit(1);
    }

    std::string result(str);

    free(str);
    str=NULL;

    return result;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

std::string strprintf(const char *fmt,...) {
    va_list v;

    va_start(v,fmt);
    std::string result=strprintfv(fmt,v);
    va_end(v);

    return result;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//static const char URL_PREFIX[]="http://visual6502.org/JSSim/expert.html?";

static int GetInt(const char *str,int num_chars,int base) {
    std::string tmp;
    if(num_chars<0) {
        tmp=str;
    } else {
        tmp=std::string(str,str+num_chars);
    }

    char *ep;
    long l=strtol(tmp.c_str(),&ep,base);

    TEST_EQ_II(*ep,0);
    TEST_TRUE(l>=INT_MIN&&l<=INT_MAX);

    return (int)l;
}

static void AddIRQ(int level,const char *v) {
    int irq_cycle=GetInt(v,-1,10);
    TEST_TRUE(irq_cycle%2==1);
    g_irqs.emplace_back(level,irq_cycle);
}

static void AddNMI(int level,const char *v) {
    int nmi_cycle=GetInt(v,-1,10);
    TEST_TRUE(nmi_cycle%2==1);
    g_nmis.emplace_back(level,nmi_cycle);
}

static void InitVisual6502(const std::string &url) {
    g_irqs.clear();
    g_nmis.clear();

    memset(g_mem,0,65536);
    memcpy(g_mem,DEFAULT_MEMORY,sizeof DEFAULT_MEMORY);

    if(!url.empty()) {
        std::string::size_type query_pos=url.find_first_of("?");
        TEST_TRUE(query_pos!=std::string::npos);

        char *args=strdup(url.c_str()+query_pos+1);

        int address=-1;

        // this isn't the cleverest
        for(char *tok=strtok(args,"&");tok;tok=strtok(NULL,"&")) {
            char *k=strdup(tok);

            char *v=strchr(k,'=');
            TEST_NON_NULL(v);
            *v++=0;

            if(strcmp(k,"a")==0) {
                address=GetInt(v,-1,16);
            } else if(strcmp(k,"d")==0) {
                TEST_EQ_UU(strlen(v)%2,0);
                for(size_t i=0;v[i]!=0;i+=2) {
                    g_mem[(uint16_t)address++]=(uint8_t)GetInt(v+i,2,16);
                }
            } else if(strcmp(k,"r")==0) {
                int r=GetInt(v,-1,16);
                g_mem[0xfffc]=(uint8_t)(r>>0);
                g_mem[0xfffd]=(uint8_t)(r>>8);
            } else if(strcmp(k,"irq0")==0) {
                AddIRQ(0,v);
            } else if(strcmp(k,"irq1")==0) {
                AddIRQ(1,v);
            } else if(strcmp(k,"nmi0")==0) {
                AddNMI(0,v);
            } else if(strcmp(k,"nmi1")==0) {
                AddNMI(1,v);
            } else if(strcmp(k,"steps")==0) {
                int steps=GetInt(v,-1,10);
                TEST_TRUE(steps%2==0);
                g_num_test_cycles=steps/2;
            } else if(strcmp(k,"r")==0) {
                address=GetInt(v,-1,16);
                TEST_EQ_II(address&~0xffff,0);
                g_mem[0xfffc]=(uint8_t)(address>>0);
                g_mem[0xfffd]=(uint8_t)(address>>8);
            }
        }

        free(args);
        args=NULL;
    }

    memcpy(memory,g_mem,65536);
}

static void TestInitVisual6502(void) {
    InitVisual6502("http://visual6502.org/JSSim/expert.html?graphics=f&loglevel=2&steps=50&a=0011&d=58&a=fffe&d=2000&a=0020&d=e840&r=0010&irq0=19&irq1=101&logmore=irq,D1x1&a=0014&d=78");
    TEST_EQ_UU(g_mem[0x11],0x58);
    TEST_EQ_UU(g_mem[0xfffe],0x20);
    TEST_EQ_UU(g_mem[0xffff],0x00);
    TEST_EQ_UU(g_mem[0x0020],0xe8);
    TEST_EQ_UU(g_mem[0x0021],0x40);
    TEST_EQ_UU(g_mem[0x0014],0x78);
    TEST_EQ_UU(g_irqs.size(),2);
    TEST_EQ_II(g_irqs[0].level,0);
    TEST_EQ_II(g_irqs[0].cycle,19);
    TEST_EQ_II(g_irqs[1].level,1);
    TEST_EQ_II(g_irqs[1].cycle,101);
}

static const PinState *FindPinStateByCycle(const std::vector<PinState> &states,int cycle_) {
    for(size_t i=0;i<states.size();++i) {
        if(states[i].cycle==cycle_) {
            return &states[i];
        }
    }

    return NULL;
}

static void TestVisual6502URL(const std::string &description,const std::string &url) {

    printf("************************************************************************\n");
    printf("\n");
    printf("%s\n",description.c_str());
    printf("\n");

    InitVisual6502(url);

    // Create perfect6502 state.
    initAndResetChip();

    // Wait for the 6502 to reach the equivalent of the simulator's
    // initial state.
    while(readAddressBus()!=0xfffd) {
        step();
    }

    // Create M6502 state.
    auto s=new M6502;
    M6502_Init(s,&M6502_nmos6502_config);
    s->tfn=&M6502_NextInstruction;

    // Copy p6502 state.
    s->a=readA();
    s->x=readX();
    s->y=readY();
    M6502_SetP(s,readP());
    s->s.b.l=readSP();
    s->pc.b.l=g_mem[0xfffc];
    s->pc.b.h=g_mem[0xfffd];

    int first_discrepancy_cycle=-1;

    // Run.

    // get to phase 2.
    step();

    int cycle=0;

    for(int i=0;i<g_num_test_cycles;++i) {
        //int printCycle=cycle/2;

        step();
        printf("%-3d ",cycle);
        chipStatus();
        ++cycle;

        const PinState *irq_state=FindPinStateByCycle(g_irqs,cycle);
        const PinState *nmi_state=FindPinStateByCycle(g_nmis,cycle);

        if(irq_state) {
            setIRQ(irq_state->level);
        }

        if(nmi_state) {
            setNMI(nmi_state->level);
        }

        step();
        printf("%-3d ",cycle);
        chipStatus();
        ++cycle;

        const char *old_state=M6502_GetStateName(s);

        //TEST_FALSE(s->p.bits._);
        (*s->tfn)(s);
        //TEST_FALSE(s->p.bits._);
        if(s->read) {
            s->dbus=g_mem[s->abus.w];
        } else {
            g_mem[s->abus.w]=s->dbus;
        }

        if(irq_state) {
            M6502_SetDeviceIRQ(s,1,irq_state->level==0);
        }

        if(nmi_state) {
            M6502_SetDeviceNMI(s,1,nmi_state->level==0);
        }

        {
            M6502P p=M6502_GetP(s);
            printf("      AB:%04X      RW:%d PC:%04X A:%02X X:%02X Y:%02X SP:%02X P:%02X       %d%d%d",
                s->abus.w,s->read,s->pc.w,s->a,s->x,s->y,s->s.b.l,p.value,
                s->device_irq_flags?0:1,
                s->device_nmi_flags?0:1,
                s->d1x1);
            printf(" %c$%04X=$%02X",s->read?'R':'W',s->abus.w,g_mem[s->abus.w]);
            printf(" %s -> ",old_state);
            old_state=NULL;
            printf("%s\n",M6502_GetStateName(s));
        }

        if(s->abus.w!=readAddressBus()||!!s->read!=!!readRW()||s->dbus!=readDataBus()) {
            printf("***** discrepancy\n");

            if(first_discrepancy_cycle<0) {
                first_discrepancy_cycle=cycle-1;
            }
        } else {
            printf("\n");
        }
    }

    printf("\n");
    printf("%s\n",description.c_str());
    printf("\n");
    printf("************************************************************************\n");

    TEST_EQ_II(first_discrepancy_cycle,-1);

    InitVisual6502("");
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

struct TestCase {
    std::string description;
    std::string url;

    // if any test has its prefer flag set, run only tests with the
    // prefer flag set.
    bool prefer=false;
};
typedef struct TestCase TestCase;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

static int g_tc_mem[65536];//-1 if not set
static int g_tc_num_cycles=120;
static uint16_t g_tc_next_addr=0;
std::vector<int> g_tc_irqs,g_tc_nmis;
std::vector<TestCase> g_test_cases;

static void SetTCVectors(uint16_t nmiv,uint16_t rstv,uint16_t irqv) {
    g_tc_mem[0xfffa]=nmiv>>0;
    g_tc_mem[0xfffb]=nmiv>>8;
    g_tc_mem[0xfffc]=rstv>>0;
    g_tc_mem[0xfffd]=rstv>>8;
    g_tc_mem[0xfffe]=irqv>>0;
    g_tc_mem[0xffff]=irqv>>8;
}

static void SetTCMem(int addr,const char *bytes) {
    uint16_t a;
    if(addr<0) {
        a=g_tc_next_addr;
    } else {
        a=(uint16_t)addr;
    }

    const char *c=bytes;
    while(*c!=0) {
        if(isspace(*c)) {
            ++c;
            continue;
        }

        char hc=*c++;
        TEST_TRUE(isxdigit(hc));

        char lc=*c++;
        TEST_TRUE(isxdigit(lc));

        uint8_t value=unhex(hc)<<4|unhex(lc);
        g_tc_mem[a]=value;
        ++a;
    }

    g_tc_next_addr=a;
}

static void ResetTC(void) {
    g_tc_irqs.clear();
    g_tc_nmis.clear();

    for(int i=0;i<65536;++i) {
        g_tc_mem[i]=-1;
    }

    // Overwrite the Visual6502 standard bits
    for(size_t i=0;i<sizeof DEFAULT_MEMORY;++i) {
        if(DEFAULT_MEMORY[i]!=0) {
            g_tc_mem[i]=0;
        }
    }

    // Add the preamble
    //
    // After the preamble: A=0, X=0, Y=0, S=255, P=nv__dIZc
    SetTCMem(0x0000,"a2ff 9a e8 8a a8 18 d8 b8 eaeaeaeaeaeaea");
    //TEST_EQ_II(g_tc_mem[15],0xea);
    //TEST_EQ_II(g_tc_mem[16],-1);

    // IRQ handler
    g_tc_mem[0x40]=0x40;

    // NMI handler
    g_tc_mem[0x50]=0x40;

    g_tc_num_cycles=120;

    SetTCVectors(0x0050,0x0000,0x0040);
}

static std::string GetTCURL(const std::string &base) {
    std::string url=base+"?graphics=f&loglevel=2&logmore=irq,nmi,D1x1&steps="+std::to_string(g_tc_num_cycles);

    int a=-1;
    for(int b=0;b<65537;++b) {
        if(b<65536&&g_tc_mem[b]>=0) {
            if(a<0) {
                a=b;
            }
        } else {
            if(a>=0) {
                url+=strprintf("&a=%04x&d=",a);
                for(int j=a;j<b;++j) {
                    url+=strprintf("%02x",g_tc_mem[j]);
                }

                a=-1;
            }
        }
    }

    for(size_t i=0;i<g_tc_irqs.size();++i) {
        url+=strprintf("&irq%zu=%d",i%2,g_tc_irqs[i]);
    }

    for(size_t i=0;i<g_tc_nmis.size();++i) {
        url+=strprintf("&nmi%zu=%d",i%2,g_tc_nmis[i]);
    }

    return url;
}

static void AddTC(const char *fmt,...) {
    TestCase tc;

    va_list v;
    va_start(v,fmt);
    tc.description=strprintfv(fmt,v);
    va_end(v);

    tc.url=GetTCURL("file:///C:/tom/github/visual6502/expert.html");

    g_test_cases.push_back(tc);
}

// Mark the last TC as preferred.
static void PreferTC(void) {
    TEST_FALSE(g_test_cases.empty());
    g_test_cases.back().prefer=true;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

static void AddTestCases(void) {
    ResetTC();
    {
        SetTCMem(0x10,"e6ff 90fc");//.L:inc $ff:bcc L

        AddTC("Preamble + simple loop");
    }

    ResetTC();
    {
        SetTCMem(0x10,"58 e6ff 78 eaea eaea eaea eaea eaea eaea");//cli:inc $ff:sei:nop...

        for(int i=0;i<3;++i) {
            g_tc_irqs={75-i*2};

            AddTC("IRQ at end-%d of INC, then SEI",i);
        }
    }

    ResetTC();
    {
        // 58=cli, 78=sei
        for(int i=0;i<50;++i)
            g_tc_mem[0x10+i]=i%2==0?0x58:0x78;


        g_tc_irqs={1};

        AddTC("Stream of CLI/SEI/CLI/SEI with IRQ held low the whole time");
    }

    ResetTC();
    {
        SetTCMem(0x10,"4c8000");

        // d0=bne (not taken); f0=beq (taken); 10=bpl (taken)
        SetTCMem(0x80,"a900 d000 a900 f000 a900 107f");
        SetTCMem(0x100,"eaeaeaeaeaeaeaeaeaeaeaeaeaeaeaea 4c0001");

        AddTC("Branch instruction timings");
    }

    ResetTC();
    {
        SetTCMem(0x10,"5890fe");

        for(int i=0;i<10;++i) {
            int cycle=65+i*2;
            g_tc_irqs={cycle};

            //if(cycle!=67&&cycle!=73&&cycle!=79)
            AddTC("Branch taken to same page - IRQ on cycle %d",g_tc_irqs[0]);

            //if(cycle==65)
            //    PreferTC();
        }
    }

    ResetTC();
    {
        SetTCMem(0x10,"ca 88 0a");//dex:dey:asl A

        AddTC("Single-byte instructions timing");
    }

    ResetTC();
    {
        // a2=ldx #; a0=ldy #
        SetTCMem(0x10,"a280a080");//ldx #$80; ldy #$80
        SetTCMem(-1,"a900");//lda #0
        SetTCMem(-1,"a500 b500");// lda $00; lda $00,X
        SetTCMem(-1,"ad0010");//lda $1000
        SetTCMem(-1,"bd0010 bd9010");//lda $1000,X; lda $1090,X
        SetTCMem(-1,"b90010 b99010");//lda $1000,Y; lda $1090,Y
        SetTCMem(-1,"a100");//lda ($80,X)
        SetTCMem(-1,"b180 b182");//lda ($80),Y; lda ($82),Y

        SetTCMem(0x80,"0030 9030");

        g_tc_num_cycles=200;

        AddTC("Read instructions timing");
    }

    ResetTC();
    {
        // a2=ldx #; a0=ldy #
        SetTCMem(0x10,"a280a080");//ldx #$80; ldy #$80
        SetTCMem(-1,"8500 9500");// sta $00; sta $00,X
        SetTCMem(-1,"8d0010");//sta $1000
        SetTCMem(-1,"9d0010 9d9010");//sta $1000,X; sta $1090,X
        SetTCMem(-1,"990010 999010");//sta $1000,Y; sta $1090,Y
        SetTCMem(-1,"8100");//sta ($80,X)
        SetTCMem(-1,"9180 9182");//sta ($80),Y; sta ($82),Y

        SetTCMem(0x80,"0030 9030");

        g_tc_num_cycles=200;

        AddTC("Store instructions timing");
    }

    ResetTC();
    {
        SetTCMem(-1,"a200a000");//ldx #0 ldy #0
        SetTCMem(-1,"4680 4e0080 5680 5e0080");
        SetTCMem(-1,"0380 1380");//slo* ($80,x); slo* ($80),y

        g_tc_num_cycles=200;

        AddTC("Read-modify-write instructions");
    }

    ResetTC();
    {
        SetTCMem(-1,"48 68 209000");//pha pla jsr $0090
        SetTCMem(-1,"a900 48 a9b0 48 4c a000");

        SetTCMem(0x90,"60");
        SetTCMem(0xa0,"08 40");//php rti
        SetTCMem(0xb0,"6c 0010");
        SetTCMem(0x1000,"c000");
        SetTCMem(0xc0,"ea00");

        g_tc_num_cycles=200;

        AddTC("Miscellaneous instructions timing");
    }

    ResetTC();
    {
        SetTCMem(-1,"90fe");

        for(int i=0;i<10;++i) {
            int cycle=61+i*2;

            g_tc_irqs={cycle};
            g_tc_nmis={cycle};

            AddTC("Simultaneous IRQ and NMI on cycle %d",cycle);

            g_tc_irqs.push_back(cycle+2);
            g_tc_nmis.push_back(cycle+2);

            AddTC("Simultaneous 2-cycle IRQ+NMI blip on cycle %d",cycle);
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
    //{
    //    "IRQ in 3rd cycle of branch taken to same page is delayed by 1 instruction",
    //    "http://visual6502.org/JSSim/expert.html?graphics=f&loglevel=2&steps=100&a=0010&d=581890fe&a=fffe&d=3000&a=0030&d=40&r=0010&irq0=15&irq1=31&logmore=irq,D1x1",
    //},
    //{
    //    "NMI",
    //    "http://visual6502.org/JSSim/expert.html?graphics=f&a=fffa&d=2000&a=20&d=40&a=0&d=eaeaeaeaeaeaeaeaeaea4c0000&steps=100&nmi0=13&loglevel=3&logmore=irq,nmi,D1x1",
    //},
    //{
    //    "Simultaneous IRQ and NMI",
    //    "http://visual6502.org/JSSim/expert.html?graphics=f&a=fffe&d=3000&a=30&d=40&a=fffa&d=2000&a=20&d=40&a=0&d=a2ff9a58eaeaeaeaeaeaeaeaeaea4c0002&steps=150&nmi0=21&irq0=21&loglevel=3&logmore=irq,nmi,D1x1",
    //},
    //{
    //    "IRQ then late NMI when pushing PCL (NMI gets priority)",
    //    "http://visual6502.org/JSSim/expert.html?graphics=f&a=fffe&d=3000&a=30&d=40&a=fffa&d=2000&a=20&d=40&a=0&d=58eaeaeaeaeaeaeaeaeaea4c0000&steps=100&nmi0=31&irq0=21&loglevel=3&logmore=irq,nmi,D1x1",
    //},
    //{
    //    "IRQ then late NMI when pushing P (IRQ gets priority)",
    //    "http://visual6502.org/JSSim/expert.html?graphics=f&a=fffe&d=3000&a=30&d=40&a=fffa&d=2000&a=20&d=40&a=0&d=58eaeaeaeaeaeaeaeaeaea4c0000&steps=100&nmi0=33&irq0=21&loglevel=3&logmore=irq,nmi,D1x1",
    //},

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

static void WriteTestHTML(void) {
    FILE *f=fopen("visual6502tests.html","wt");
    fprintf(f,"<html><head><title>Visual 6502 test cases</title></head><body><h1>Visual 6502 Test Cases</h1><ul>");
    for(size_t i=0;i<g_test_cases.size();++i) {
        fprintf(f,"<li><a href=\"%s\">",g_test_cases[i].url.c_str());
        for(char c:g_test_cases[i].description) {
            switch(c) {
            case '\'':
                fprintf(f,"&apos;");
                break;

            case '&':
                fprintf(f,"&amp;");
                break;

            case '<':
                fprintf(f,"&lt;");
                break;

            case '>':
                fprintf(f,"&gt;");
                break;

            default:
                fprintf(f,"%c",c);
                break;
            }
        }
        fprintf(f,"</a>");
    }
    fprintf(f,"</body></html>");
    fclose(f);
    f=NULL;

}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

int main(void) {
    (void)&PreferTC;

    TestInitVisual6502();

    AddTestCases();

    WriteTestHTML();

    for(size_t i=0;i<g_test_cases.size();++i)
        LOGF(DEBUG,"%s\n",g_test_cases[i].url.c_str());

    int check_prefer=0;
    for(size_t i=0;i<g_test_cases.size();++i) {
        const TestCase *tc=&g_test_cases[i];

        if(tc->prefer) {
            check_prefer=1;
            break;
        }
    }

    for(size_t i=0;i<g_test_cases.size();++i) {
        const TestCase *tc=&g_test_cases[i];

        if(check_prefer) {
            if(!tc->prefer) {
                continue;
            }
        }

        TestVisual6502URL(tc->description,tc->url);
    }

    return 0;
}
